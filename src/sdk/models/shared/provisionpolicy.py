"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectorprovision import ConnectorProvision, ConnectorProvisionTypedDict
from .delegatedprovision import DelegatedProvision, DelegatedProvisionTypedDict
from .externalticketprovision import ExternalTicketProvision, ExternalTicketProvisionTypedDict
from .manualprovision import ManualProvision, ManualProvisionTypedDict
from .multistep import MultiStep, MultiStepTypedDict
from .webhookprovision import WebhookProvision, WebhookProvisionTypedDict
import pydantic
from pydantic import model_serializer
from sdk.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from typing import TypedDict
from typing_extensions import Annotated, NotRequired


class ProvisionPolicyTypedDict(TypedDict):
    r"""ProvisionPolicy is a oneOf that indicates how a provision step should be processed.

    This message contains a oneof named typ. Only a single field of the following list may be set at a time:
    - connector
    - manual
    - delegated
    - webhook
    - multiStep
    - externalTicket

    """
    
    connector_provision: NotRequired[Nullable[ConnectorProvisionTypedDict]]
    r"""Indicates that a connector should perform the provisioning. This object has no fields."""
    delegated_provision: NotRequired[Nullable[DelegatedProvisionTypedDict]]
    r"""This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement."""
    external_ticket_provision: NotRequired[Nullable[ExternalTicketProvisionTypedDict]]
    r"""This provision step indicates that we should check an external ticket to provision this entitlement"""
    manual_provision: NotRequired[Nullable[ManualProvisionTypedDict]]
    r"""Manual provisioning indicates that a human must intervene for the provisioning of this step."""
    multi_step: NotRequired[Nullable[MultiStepTypedDict]]
    r"""MultiStep indicates that this provision step has multiple steps to process."""
    webhook_provision: NotRequired[Nullable[WebhookProvisionTypedDict]]
    r"""This provision step indicates that a webhook should be called to provision this entitlement."""
    

class ProvisionPolicy(BaseModel):
    r"""ProvisionPolicy is a oneOf that indicates how a provision step should be processed.

    This message contains a oneof named typ. Only a single field of the following list may be set at a time:
    - connector
    - manual
    - delegated
    - webhook
    - multiStep
    - externalTicket

    """
    
    connector_provision: Annotated[OptionalNullable[ConnectorProvision], pydantic.Field(alias="connector")] = UNSET
    r"""Indicates that a connector should perform the provisioning. This object has no fields."""
    delegated_provision: Annotated[OptionalNullable[DelegatedProvision], pydantic.Field(alias="delegated")] = UNSET
    r"""This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement."""
    external_ticket_provision: Annotated[OptionalNullable[ExternalTicketProvision], pydantic.Field(alias="externalTicket")] = UNSET
    r"""This provision step indicates that we should check an external ticket to provision this entitlement"""
    manual_provision: Annotated[OptionalNullable[ManualProvision], pydantic.Field(alias="manual")] = UNSET
    r"""Manual provisioning indicates that a human must intervene for the provisioning of this step."""
    multi_step: Annotated[OptionalNullable[MultiStep], pydantic.Field(alias="multiStep")] = UNSET
    r"""MultiStep indicates that this provision step has multiple steps to process."""
    webhook_provision: Annotated[OptionalNullable[WebhookProvision], pydantic.Field(alias="webhook")] = UNSET
    r"""This provision step indicates that a webhook should be called to provision this entitlement."""
    
    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["ConnectorProvision", "DelegatedProvision", "ExternalTicketProvision", "ManualProvision", "MultiStep", "WebhookProvision"]
        nullable_fields = ["ConnectorProvision", "DelegatedProvision", "ExternalTicketProvision", "ManualProvision", "MultiStep", "WebhookProvision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (self.__pydantic_fields_set__.intersection({n}) or k in null_default_fields) # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
        
