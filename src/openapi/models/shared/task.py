"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .externalref import ExternalRef, ExternalRefTypedDict
from .policyinstance import PolicyInstance, PolicyInstanceTypedDict
from .tasktype import TaskType, TaskTypeTypedDict
from datetime import datetime
from enum import Enum
from openapi.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from openapi.utils import serialize_int, validate_int
import pydantic
from pydantic import ConfigDict, model_serializer
from pydantic.functional_serializers import PlainSerializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, Dict, List, Optional, TypedDict
from typing_extensions import Annotated, NotRequired


class Actions(str, Enum):
    TASK_ACTION_TYPE_UNSPECIFIED = "TASK_ACTION_TYPE_UNSPECIFIED"
    TASK_ACTION_TYPE_CLOSE = "TASK_ACTION_TYPE_CLOSE"
    TASK_ACTION_TYPE_APPROVE = "TASK_ACTION_TYPE_APPROVE"
    TASK_ACTION_TYPE_DENY = "TASK_ACTION_TYPE_DENY"
    TASK_ACTION_TYPE_COMMENT = "TASK_ACTION_TYPE_COMMENT"
    TASK_ACTION_TYPE_DELETE = "TASK_ACTION_TYPE_DELETE"
    TASK_ACTION_TYPE_REASSIGN = "TASK_ACTION_TYPE_REASSIGN"
    TASK_ACTION_TYPE_RESTART = "TASK_ACTION_TYPE_RESTART"
    TASK_ACTION_TYPE_SEND_REMINDER = "TASK_ACTION_TYPE_SEND_REMINDER"
    TASK_ACTION_TYPE_PROVISION_COMPLETE = "TASK_ACTION_TYPE_PROVISION_COMPLETE"
    TASK_ACTION_TYPE_PROVISION_CANCELLED = "TASK_ACTION_TYPE_PROVISION_CANCELLED"
    TASK_ACTION_TYPE_PROVISION_ERRORED = "TASK_ACTION_TYPE_PROVISION_ERRORED"
    TASK_ACTION_TYPE_PROVISION_APP_USER_TARGET_CREATED = "TASK_ACTION_TYPE_PROVISION_APP_USER_TARGET_CREATED"
    TASK_ACTION_TYPE_ROLLBACK_SKIPPED = "TASK_ACTION_TYPE_ROLLBACK_SKIPPED"
    TASK_ACTION_TYPE_HARD_RESET = "TASK_ACTION_TYPE_HARD_RESET"
    TASK_ACTION_TYPE_ESCALATE_TO_EMERGENCY_ACCESS = "TASK_ACTION_TYPE_ESCALATE_TO_EMERGENCY_ACCESS"
    TASK_ACTION_TYPE_CHANGE_POLICY = "TASK_ACTION_TYPE_CHANGE_POLICY"
    TASK_ACTION_TYPE_RECALCULATE_DENIAL_FROM_BASE_POLICY_DECISIONS = "TASK_ACTION_TYPE_RECALCULATE_DENIAL_FROM_BASE_POLICY_DECISIONS"
    TASK_ACTION_TYPE_SET_INSIGHTS_AND_RECOMMENDATION = "TASK_ACTION_TYPE_SET_INSIGHTS_AND_RECOMMENDATION"
    TASK_ACTION_TYPE_SET_ANALYSIS_ID = "TASK_ACTION_TYPE_SET_ANALYSIS_ID"
    TASK_ACTION_TYPE_RECALCULATE_APPROVERS_LIST = "TASK_ACTION_TYPE_RECALCULATE_APPROVERS_LIST"

class AnnotationsTypedDict(TypedDict):
    r"""Contains an arbitrary serialized message along with a @type that describes the type of the serialized message."""
    
    at_type: NotRequired[str]
    r"""The type of the serialized message."""
    

class Annotations(BaseModel):
    r"""Contains an arbitrary serialized message along with a @type that describes the type of the serialized message."""
    model_config = ConfigDict(populate_by_name=True, arbitrary_types_allowed=True, extra="allow")
    __pydantic_extra__:  Dict[str, Any] = pydantic.Field(init=False)
    
    at_type: Annotated[Optional[str], pydantic.Field(alias="@type")] = None
    r"""The type of the serialized message."""
    
    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value # pyright: ignore[reportIncompatibleVariableOverride]
    

class Processing(str, Enum):
    r"""The processing state of a task as defined by the `processing_enum`"""
    TASK_PROCESSING_TYPE_UNSPECIFIED = "TASK_PROCESSING_TYPE_UNSPECIFIED"
    TASK_PROCESSING_TYPE_PROCESSING = "TASK_PROCESSING_TYPE_PROCESSING"
    TASK_PROCESSING_TYPE_WAITING = "TASK_PROCESSING_TYPE_WAITING"
    TASK_PROCESSING_TYPE_DONE = "TASK_PROCESSING_TYPE_DONE"

class Recommendation(str, Enum):
    r"""The recommendation field."""
    INSIGHT_RECOMMENDATION_UNSPECIFIED = "INSIGHT_RECOMMENDATION_UNSPECIFIED"
    INSIGHT_RECOMMENDATION_APPROVE = "INSIGHT_RECOMMENDATION_APPROVE"
    INSIGHT_RECOMMENDATION_DENY = "INSIGHT_RECOMMENDATION_DENY"
    INSIGHT_RECOMMENDATION_REVIEW = "INSIGHT_RECOMMENDATION_REVIEW"

class TaskState(str, Enum):
    r"""The current state of the task as defined by the `state_enum`"""
    TASK_STATE_UNSPECIFIED = "TASK_STATE_UNSPECIFIED"
    TASK_STATE_OPEN = "TASK_STATE_OPEN"
    TASK_STATE_CLOSED = "TASK_STATE_CLOSED"

class TaskTypedDict(TypedDict):
    r"""A fully-fleged task object. Includes its policy, references to external apps, its type, its processing history, and more."""
    
    policy_instance: NotRequired[PolicyInstanceTypedDict]
    r"""A policy instance is an object that contains a reference to the policy it was created from, the currently executing step, the next steps, and the history of previously completed steps."""
    task_type: NotRequired[TaskTypeTypedDict]
    r"""Task Type provides configuration for the type of task: certify, grant, or revoke

    This message contains a oneof named task_type. Only a single field of the following list may be set at a time:
    - grant
    - revoke
    - certify
    - offboarding

    """
    actions: NotRequired[Nullable[List[Actions]]]
    r"""The actions that can be performed on the task by the current user."""
    analysis_id: NotRequired[str]
    r"""The ID of the analysis object associated with this task created by an analysis workflow if the analysis feature is enabled for your tenant."""
    annotations: NotRequired[Nullable[List[AnnotationsTypedDict]]]
    r"""An array of `google.protobuf.Any` annotations with various base64-encoded data."""
    comment_count: NotRequired[int]
    r"""The count of comments."""
    created_at: NotRequired[datetime]
    created_by_user_id: NotRequired[str]
    r"""The ID of the user that is the creator of this task. This may not always match the userId field."""
    deleted_at: NotRequired[datetime]
    description: NotRequired[str]
    r"""The description of the task. This is also known as justification."""
    display_name: NotRequired[str]
    r"""The display name of the task."""
    emergency_access: NotRequired[bool]
    r"""A field indicating whether this task was created using an emergency access flow, or escalated to emergency access. On task creation, it will also use the app entitlement's emergency policy when possible."""
    external_refs: NotRequired[Nullable[List[ExternalRefTypedDict]]]
    r"""An array of external references to the task. Historically that has been items like Jira task IDs. This is currently unused, but may come back in the future for integrations."""
    id: NotRequired[str]
    r"""The ID of the task."""
    insight_ids: NotRequired[Nullable[List[str]]]
    r"""The insightIds field."""
    numeric_id: NotRequired[int]
    r"""A human-usable numeric ID of a task which can be included in place of the fully qualified task id in path parmeters (but not search queries)."""
    policy_generation_id: NotRequired[str]
    r"""The policy generation id refers to the current policy's generation ID. This is changed when the policy is changed on a task."""
    processing: NotRequired[Processing]
    r"""The processing state of a task as defined by the `processing_enum`"""
    recommendation: NotRequired[Recommendation]
    r"""The recommendation field."""
    state: NotRequired[TaskState]
    r"""The current state of the task as defined by the `state_enum`"""
    step_approver_ids: NotRequired[Nullable[List[str]]]
    r"""An array of IDs belonging to Identity Users that are allowed to review this step in a task."""
    updated_at: NotRequired[datetime]
    user_id: NotRequired[str]
    r"""The ID of the user that is the target of this task. This may be empty if we're targeting a specific app user that has no known identity user."""
    

class Task(BaseModel):
    r"""A fully-fleged task object. Includes its policy, references to external apps, its type, its processing history, and more."""
    
    policy_instance: Annotated[Optional[PolicyInstance], pydantic.Field(alias="policy")] = None
    r"""A policy instance is an object that contains a reference to the policy it was created from, the currently executing step, the next steps, and the history of previously completed steps."""
    task_type: Annotated[Optional[TaskType], pydantic.Field(alias="type")] = None
    r"""Task Type provides configuration for the type of task: certify, grant, or revoke

    This message contains a oneof named task_type. Only a single field of the following list may be set at a time:
    - grant
    - revoke
    - certify
    - offboarding

    """
    actions: OptionalNullable[List[Actions]] = UNSET
    r"""The actions that can be performed on the task by the current user."""
    analysis_id: Annotated[Optional[str], pydantic.Field(alias="analysisId")] = None
    r"""The ID of the analysis object associated with this task created by an analysis workflow if the analysis feature is enabled for your tenant."""
    annotations: OptionalNullable[List[Annotations]] = UNSET
    r"""An array of `google.protobuf.Any` annotations with various base64-encoded data."""
    comment_count: Annotated[Optional[int], pydantic.Field(alias="commentCount")] = None
    r"""The count of comments."""
    created_at: Annotated[Optional[datetime], pydantic.Field(alias="createdAt")] = None
    created_by_user_id: Annotated[Optional[str], pydantic.Field(alias="createdByUserId")] = None
    r"""The ID of the user that is the creator of this task. This may not always match the userId field."""
    deleted_at: Annotated[Optional[datetime], pydantic.Field(alias="deletedAt")] = None
    description: Optional[str] = None
    r"""The description of the task. This is also known as justification."""
    display_name: Annotated[Optional[str], pydantic.Field(alias="displayName")] = None
    r"""The display name of the task."""
    emergency_access: Annotated[Optional[bool], pydantic.Field(alias="emergencyAccess")] = None
    r"""A field indicating whether this task was created using an emergency access flow, or escalated to emergency access. On task creation, it will also use the app entitlement's emergency policy when possible."""
    external_refs: Annotated[OptionalNullable[List[ExternalRef]], pydantic.Field(alias="externalRefs")] = UNSET
    r"""An array of external references to the task. Historically that has been items like Jira task IDs. This is currently unused, but may come back in the future for integrations."""
    id: Optional[str] = None
    r"""The ID of the task."""
    insight_ids: Annotated[OptionalNullable[List[str]], pydantic.Field(alias="insightIds")] = UNSET
    r"""The insightIds field."""
    numeric_id: Annotated[Annotated[Optional[int], BeforeValidator(validate_int), PlainSerializer(serialize_int(True))], pydantic.Field(alias="numericId")] = None
    r"""A human-usable numeric ID of a task which can be included in place of the fully qualified task id in path parmeters (but not search queries)."""
    policy_generation_id: Annotated[Optional[str], pydantic.Field(alias="policyGenerationId")] = None
    r"""The policy generation id refers to the current policy's generation ID. This is changed when the policy is changed on a task."""
    processing: Optional[Processing] = None
    r"""The processing state of a task as defined by the `processing_enum`"""
    recommendation: Optional[Recommendation] = None
    r"""The recommendation field."""
    state: Optional[TaskState] = None
    r"""The current state of the task as defined by the `state_enum`"""
    step_approver_ids: Annotated[OptionalNullable[List[str]], pydantic.Field(alias="stepApproverIds")] = UNSET
    r"""An array of IDs belonging to Identity Users that are allowed to review this step in a task."""
    updated_at: Annotated[Optional[datetime], pydantic.Field(alias="updatedAt")] = None
    user_id: Annotated[Optional[str], pydantic.Field(alias="userId")] = None
    r"""The ID of the user that is the target of this task. This may be empty if we're targeting a specific app user that has no known identity user."""
    
    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["PolicyInstance", "TaskType", "actions", "analysisId", "annotations", "commentCount", "createdAt", "createdByUserId", "deletedAt", "description", "displayName", "emergencyAccess", "externalRefs", "id", "insightIds", "numericId", "policyGenerationId", "processing", "recommendation", "state", "stepApproverIds", "updatedAt", "userId"]
        nullable_fields = ["actions", "annotations", "externalRefs", "insightIds", "stepApproverIds"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields
                or (
                    k in optional_fields
                    and k in nullable_fields
                    and (
                        self.__pydantic_fields_set__.intersection({n})
                        or k in null_default_fields
                    )  # pylint: disable=no-member
                )
            ):
                m[k] = val

        return m
        
